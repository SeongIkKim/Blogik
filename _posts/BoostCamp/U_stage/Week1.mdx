---
title: 인공지능을 위한 파이썬 기초
date: 2021-01-18
tags: [BoostCamp AI Tech, Python]
excerpt: Python Basic for AI by 최성철, BoostCamp AI Tech 1주차
---
본 정리 내용은 [Naver BoostCamp AI Tech](https://boostcamp.connect.or.kr/)의 edwith에서 수강한 내용을 정리한 것입니다.  
사실과 다른 부분이 있거나, 수정이 필요한 사항은 댓글로 남겨주세요.

---

1주차

# 파이썬 개요

## Python

- 플랫폼 독립적인 인터프리터 언어(Interpreted Language)

|항목|컴파일러 언어|인터프리터 언어|
|---|:-:|:-:|
|작동방식| **소스코드를 기계어로 먼저 번역** , 해당 플랫폼에 최적화되어 프로그램 실행 |별도의 번역과정 없이 **소스코드를 실행시점에서 해석**|
|장점|실행속도가 빠름|간단히 작성, 메모리 필요량 적음|
|단점|한번에 많은 메모리 필요|실행속도가 느림|
|주요 언어|`C`, `JAVA`, `C++`, `C#`|`Python`, `Scala`|

- 객체지향 동적 타이핑 언어
    - **실행순서가 아닌 단위 모듈(객체) 중심으로 프로그램 작성**
    - method와 attribute를 가지고 있음
- 동적 타이핑 언어
    - 프로그램 **실행 시점에** 프로그램이 사용해야 할 **데이터에 대한 타입을 결정**함

# 파이썬/AI 개발환경 준비하기

## 파이썬 인터프리터

- 2.7과 3.X 버전이 존재 : 현재는 3.X 기준으로 모든 시스템이 작동됨 → 2020년부터 `Tensorflow`에서 python 2 deprecated
- 기존 라이브러리 사용 여부에 따라 버전 선택(아직 아마존에서는 python 2를 사용하는 부서가 있다고..)
- `Anaconda` : 일반적인 파이썬 인터프리터와 달리 다양한 과학계산용 모듈들을 묶어서 패키지한 인터프리터

## 코드 편집기

- 어플리케이션형
    - `VSCode`, `Anaconda`, `PyCharm`
    - 이 중 `Anaconda`는 ML의 사실상 표준
- 웹 기반 인터랙티브 편집기
    - `Jupyter`, `CoLab`
        - 편집기라기보다는 데이터 분석 도구의 느낌이 강함

## Jupyter

- IPython 커널 기반 대화형 python shell
- 일반적인 터미널 shell + 웹 기반 데이터 분석 Notebook 제공
- 미디어, 텍스트, 코드, 수식 등의 하나의 문서로 표현 가능
- 사실상 데이터분석 Interactive Shell의 표준
- **Ju**lia + **Pyt**hon + **R**

## Colab

- 구글이 개발한 클라우드기반 jupyter notebook
- Google Drive + GCP + jupyter 등이 합쳐져서 사용자가 손쉽게 접근
- 초기 모듈들이 세팅되어있다는 장점
- Google Drive 파일 업로드하여 사용 가능
- VSC 연결하여 사용 가능
- V100 이상의 GPU 무료 사용 가능

### 커맨드 정리

- `conda activate [가상환경]` - conda 가상환경 실행(디폴트 설치 가상환경 base)
- `conda deactivate` - conda 가상환경 종료
- `jupyter notebook` - jupyter 웹 즉시 실행. 커맨드 실행 폴더가 root dir
- Jupyter 커맨드
    - `cmd + return` - 셀 수행(메모리 적재)
    - `opt + return` - 새로운 셀 생성 후 전환
    - `shift + tap` - 툴팁
    - `cmd + <,>` - 들여쓰기, 내어쓰기
    - 작성 중 `esc` - 코멘트 모드 (작성중은 에디터 모드)
        - `b` - 아래쪽에 셀 추가
        - `a` - 위쪽에 셀 추가
        - `ii` - 실행 중지
        - `dd` - 셀 삭제
        - `z` - 셀 지우기 취소
        - `shift  + m` - 셀 병합
        - `x` - 셀 오려두기
        - `v` - 새 셀 생성 후 붙여넣기
        - `mm` - 마크다운 변환
        - `yy` - 코드로 변환
        - `h` - 단축키 확인
- Colab 커맨드
    - 미묘하게 Jupyter와 다르니 자료를 보고 학습할 것
- VSC 커맨드
    - 드래그 후 `cmd + d` - 드래그한 코드와 같은 코드들을 일괄 지정하여 수정 가능
    - `opt + click` - 다중 커서 설정
    - `opt + up/down` - 드래그 X 시 해당 라인만, 드래그 O 시 해당 범위 통째로 코드 이동
    - `opt + shift + up/down` - 드래그  X 시 해당 라인만, 드래그 O시 해당 범위 통째로 복사하여 코드 이동
    - `opt + shift + i` - 드래그 한 모든 줄의 끝부분에 다중 커서 생성
    - `opt + shift + 드래그` - 현재 커서 위치 기준으로 드래그한 모든 라인에 다중 커서 생성
    - `cmd + return` - 현재 커서 위치와 관계없이 다음 줄로 커서 이동(엔터)
    - `cmd + u` - 이전 커서 위치로 이동
    - `cmd + b` - 프로젝트 디렉토리 사이드바 토글
    - `cmd + p` - 파일 퀵 오픈
    - `cmd + ,` - 유저 세팅 오픈
    - `cmd + k + s` - 단축키 확인


# 파이썬 기초

## 변수

`var = value` 에서 value는 var에 저장되는데, var는 어디에 저장될까?

변수는 값을 저장하는 장소이며, 변수도 메모리 주소를 가지고 있다. 따라서 **변수에 들어가는 값은 메모리 주소에 할당**된다.

따라서 `var = value` 의 의미는 "A는 8이다"가 아닌, 
**"A라는 이름을 가진 메모리 주소에 8을 저장하라"**의 의미와 같다.

## Dynamic Typing

코드 실행시점에 데이터의 Type을 결정하는 방법. 파이썬과 같은 **동적 언어들의 장점이자 단점**.

할당시킬 value를 보고 변수의 타입을 결정하기 때문에, 일반적인 정적 언어(`JAVA`,`C` 등)처럼 일일이 타입 명을 붙여주지 않아도 되고, 계산 중간에 변수의 타입을 바꿀수도 있다.

그러나 역으로, 타입을 추론해야하므로 정적 언어에 비해 느릴 뿐만 아니라 예상치못한 타입에러를 뿜는 경우가 종종 있다. 경험상으로는, `None` type등 알맞지 않은 value를 받아도 에러가 나지 않고 여러 함수를 거친 뒤에야 문제가 터져 tracing이 굉장히 힘들었던 경험이 있다.

이러한 문제 때문에 `JavaScript`는  `TypeScript`라는 새로운 정적 타이핑형 variable이 생겨났고, `Python`에서도 3.5 이후에 PEP 484에 기반하여  `typing`과 같은 타입 힌트 모듈이 생겨나는 계기가 되었다.

## 부동소수점

Python3 에서는 발생하지 않지만, Python2 까지는 부동소수점 문제가 발생한다.

컴퓨터는 **모든 수를 이진수로 바꾸어서 저장**하는데, 실수 또한 마찬가지이다.

실수를 이진수 변환한다고 생각할 때, 정확히 1로 나누어떨어지지 않는 문제 때문에 **소수점 이하 이진법 자릿수가 무한히 늘어나게 된다.** 이 경우의 반올림 오차는 그리 크지 않다.

예를 들어 0.1을 이진수 변환하면 다음과 같다.

$0.1 = 0.00011001100110011....._{(2)}$

<Info>

컴퓨터는 실리콘 반도체로 구성되어있다. 반도체는 특정 자극을 줬을 때 전류가 통하는데, 전류의 흐름을 제어하여 흐르는 상태를 1, 흐르지 않는 상태를 0으로 표현할 수 있다. 이처럼 표현할 수 있는 형태가 0, 1 두가지밖에 존재하지 않기 때문에, 반도체로 구성된 컴퓨터도 결국은 모든 수와 형태를 0과 1로 표현하게 된다. 이런 한계를 벗어나기 위해 최근에 양자컴퓨터와 같은 새로운 형태의 컴퓨터 도입을 연구하고 있다.

</Info>

## 리스트

### 패킹과 언패킹

- 패킹 : 한 변수에 여러개의 데이터를 넣는 것
- 언패킹 : 한 변수의 데이터를 각각의 변수로 변환

```python
p = [1,2,3] # 패킹
a, b, c = p # 언패킹, a=1, b=2, c=3
```

### 이차원 리스트 복사

일반적으로 리스트를 참조하지 않고 복사하고 싶을때는 `list1 = list2[:]` 의 방식을 많이 사용하곤 한다.

그러나 이는 일차원 리스트의 포인터에 한정된 개념이라, 이차원 리스트의 겉 포인터만 바뀌고 내부의 리스트 포인터는 그대로인 상태이다. 이러한 참조 상태를 피하고 싶다면, `copy` 모듈의 `deep_copy()`를 사용한다.

```python
import copy

origin = [[1,2,3], [4,5,6]]
clone = origin[:] 
clone2 = copy.deepcopy(origin)

clone[0][3] = 7

print(clone) # [[1,2,7], [4,5,6]]
print(origin) # [[1,2,7], [4,5,6]] --> 내부 리스트는 그대로 참조되어있으므로 변경됨
print(clone2) # [[1,2,3], [4,5,6]] --> 내부 리스트까지 모두 포인터가 바뀌어있으므로 변경되지 않았음
```

## 함수

어떠한 일을 수행하는 코드의 덩어리.

다음과 같은 장점을 가진다.

- 반복적인 수행을 1회만 작성 후 호출
- 코드를 논리적 단위로 분리
- 캡슐화 : 인터페이스만 알면 타인의 코드를 사용할 수 있음

따라서 코드를 **하나의 개조식, 글로 생각하고 타인이 보기쉽도록 만들어야 한다**.

### parameter와 argument

- parameter : 함수의 입력 값 인터페이스(추상화 형태)
- argument : 실제 파라미터에 대입된 값

## Console I/O

### f-string

python 3.6 이후, PEP498에 근거한 formatting 기법

```python
name = "alphaca"
print(f"I'm {name}.")
print(f'{name:20}') # 왼쪽정렬이 기본, 총 20칸 할당
print(f'{name:>20}') # 오른쪽 정렬, 총 20칸 할당
print(f'{name:*<20}') # 왼쪽 정렬, 총 20칸 할당, 문자가 없는 공간에 * 채우기
print(f'{name:*>20}') # 오른쪽 정렬, 총 20칸 할당, 문자가 없는 공간에 * 채우기
print(f'{name:*^20}') # 가운데 정렬, 총 20칸 할당, 문자가 없는 공간에 * 채우기

number = 3.141592653589793
print(f'{number:.2f}') # 실수형, 소수점 이하 2자리
```

![format_io.png](img/format_io.png)

## 조건문

### 비교 연산자 is, is not

일반적으로 자주 사용되는 `==` , `!=` 연산자는 두 var의 **값을 비교**한다.

python에는 이와 비슷하게 보이지만, **객체 메모리주소(id)를 비교**하는 비교연산자 `is` 와 `is not` 이 있다.

```python
a = 300
b = 300
c = a
print(a==b) # True, 값이 같음
print(a is b) # False, 서로 다른 객체(메모리 주소)임
print(a is c) # True, 서로 같은 객체(메모리 주소)임

# 예외 1
d = 5
e = 5
c = a
print(d==e) # True
print(d is e) # True, -5~255 까지는 python에서 정적메모리로 판단하여, 같은 객체로 연결시켜줌
print(d is f) # True

# 예외 2
print(nan is nan) # True
print(nan == nan) # False
```

자세한 내용은 StackOverflow의 해당 링크를 참조한다.

[Is there a difference between “==” and “is”?](https://stackoverflow.com/questions/132988/is-there-a-difference-between-and-is)

## 스크립트 파일과 모듈의 시작점

```python
if __name__ == "__main__": # 인터프리터에서 해당 모듈을 호출하였을경우
```

`__name__` 변수를 통해 현재 스크립트파일이 시작점인지 모듈인지 확인할 수 있다. 이 중 인터프리터는 해당 변수 value가 `__main__` 으로 존재한다.

자세한 내용은 코딩도장의 해당 파트를 참고하자.

[모듈와 시작점 알아보기](https://dojang.io/mod/page/view.php?id=2448)

## 함수 호출 방식 - Call by Object Reference

python은 함수로 argument를 넘길 때 객체의 주소를 전달한다.

전달된 객체를 **참조하여 변경**시 호출자에게 영향을 미치지만, **새로운 객체로 할당할경우** 호출자에게 영향을 주지 않는다.

```python
def decide_lunch(lunch):
	lunch.append('Milk') # 기존의 호출자를 참조 변경하므로 영향을 미침
	lunch = ['Bibimbap'] # lunch 새로운 객체를 생성한 것이므로 함수 스코프에 그침

lunch = ['Sandwich']
decide_lunch(lunch)
print(decide_lunch) # ['Sandwich', 'Milk]
```

---

환경 설정 기록

`miniconda 4.8.2` - brew cask install

`VSC`